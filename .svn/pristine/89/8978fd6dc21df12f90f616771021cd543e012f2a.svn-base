package com.zc.efounder.JEnterprise.commhandler;

import com.ruoyi.common.constant.ScheduleConstants;
import com.ruoyi.common.core.domain.AjaxResult;
import com.ruoyi.common.core.result.ResultMap;
import com.ruoyi.common.exception.job.TaskException;
import com.zc.ApplicationContextProvider;
import com.zc.efounder.JEnterprise.domain.sceneLink.SceneActuator;
import com.zc.efounder.JEnterprise.domain.sceneLink.SceneTrigger;
import com.zc.efounder.JEnterprise.mapper.sceneLink.SceneActuatorMapper;
import com.zc.efounder.JEnterprise.mapper.sceneLink.SceneTriggerMapper;
import com.zc.quartz.domain.SysJob;
import com.zc.quartz.mapper.SysJobMapper;
import com.zc.quartz.util.CronUtils;
import com.zc.quartz.util.ScheduleUtils;
import org.quartz.JobKey;
import org.quartz.Scheduler;
import org.quartz.SchedulerException;
import com.ruoyi.common.core.redis.RedisCache;
import com.ruoyi.common.utils.DateUtils;
import com.zc.common.constant.DeviceTreeConstants;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.common.core.model.DataReception;
import com.zc.connect.business.constant.DDCCmd;
import com.zc.connect.business.constant.LDCCmd;
import com.zc.connect.business.dto.ddc.PointDataDDC;
import com.zc.connect.business.dto.ldc.PointDataLDC;
import com.zc.connect.business.handler.SendMsgHandler;
import com.zc.efounder.JEnterprise.Cache.ModuleAndPointCache;
import com.zc.efounder.JEnterprise.domain.deviceTree.Controller;
import com.zc.efounder.JEnterprise.domain.deviceTree.Point;
import com.zc.efounder.JEnterprise.domain.deviceTree.PointDebugLog;
import com.zc.efounder.JEnterprise.mapper.deviceTree.PointMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.util.StringUtils;

import javax.annotation.PostConstruct;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * description:场景联动执行工具类
 * author: sunshangeng
 * date:2023/3/1 9:53
 */
@Component("SceneLinkHandler")
public class SceneLinkHandler {



    private static final Logger log = LoggerFactory.getLogger(SceneLinkHandler.class);


    private static SysJobMapper jobMapper= ApplicationContextProvider.getBean(SysJobMapper.class);

    private static SceneTriggerMapper triggerMapper= ApplicationContextProvider.getBean(SceneTriggerMapper.class);
    private static SceneActuatorMapper actuatorMapper= ApplicationContextProvider.getBean(SceneActuatorMapper.class);

    /**定时任务处理类*/
    private static Scheduler scheduler =ApplicationContextProvider.getBean(Scheduler.class);


    private static PointMapper pointMapper=ApplicationContextProvider.getBean(PointMapper.class);

    private static ModuleAndPointCache moduleAndPointCache=ApplicationContextProvider.getBean(ModuleAndPointCache.class);

    private static RedisCache redisCache =ApplicationContextProvider.getBean(RedisCache.class);

    /**场景任务前缀名*/
    public static final String SCENE_LINK_JOB_NAME_PREFIX = "场景联动_";

    /**场景任务组名*/
    public static final String SCENE_LINK_JOB_GROUP = "SCENELINKEGROUP";

    /**场景任务的目标字符串*/
    public static final String SCENE_LINK_JOB_INVOKETARGET = "SceneLinkHandler.SceneLinkJobExecute";

    /**场景任务的执行策略 默认中断后 执行一次*/
    public static final String SCENE_LINK_JOB_MISFIREPOLICY = "2";

    /**场景任务的并发配置 默认允许*/
    public static final String SCENE_LINK_JOB_CONCURRENT = "0";


    /**场景任务的启动状态 默认不运行运行*/
    public static final String SCENE_LINK_JOB_STATUS = "1";


    /**项目启动时构建触发器缓存。*/
    @PostConstruct
    public void init()
    {
        List<SceneTrigger> triggerList = triggerMapper.selectSceneTriggerAll();

        /**初始化时先清空*/
        redisCache.deleteObject(RedisKeyConstants.BES_SceneLink_Trigger);
        if(triggerList!=null&& triggerList.size()>0){
            triggerList.forEach(item->{
                redisCache.setCacheMapValue(RedisKeyConstants.BES_SceneLink_Trigger,item.getId(),item);
            });
        }

    }
    /**
     * @description:创建定时触发的触发器
     * @author: sunshangeng
     * @date: 2023/3/1 9:55
     * @param: [cron表达式,场景名称]
     * @return: com.ruoyi.common.core.result.ResultMap
     **/
    public static ResultMap createJob(String cron,String SceneName) throws TaskException, SchedulerException {

        /**验证cron表达式 是否正确*/
        if (!CronUtils.isValid(cron))
        {
            return ResultMap.error("失败，Cron表达式不正确");
        }
        /**组装job数据*/
        SysJob sysJob=new SysJob();
        sysJob.setJobName(SCENE_LINK_JOB_NAME_PREFIX+SceneName);
        sysJob.setJobGroup(SCENE_LINK_JOB_GROUP);
        sysJob.setInvokeTarget(SCENE_LINK_JOB_INVOKETARGET);
        sysJob.setCronExpression(cron);
        /**执行策略详解：
         1立即执行（所有misfire的任务会马上执行）打个比方，如果9点misfire了，在10：15系统恢复之后，9点，10点的misfire会马上执行
         2执行一次（会合并部分的misfire，正常执行下一个周期的任务）假设9，10的任务都misfire了，系统在10：15分起来了。只会执行一次misfire，下次正点执行。
         3放弃执行(所有的misfire不管，执行下一个周期的任务)*/
        sysJob.setMisfirePolicy(SCENE_LINK_JOB_MISFIREPOLICY);
        sysJob.setConcurrent(SCENE_LINK_JOB_CONCURRENT);
        sysJob.setStatus(SCENE_LINK_JOB_STATUS);
        sysJob.setCreateBy("admin");
        sysJob.setUpdateBy("admin");
        sysJob.setRemark("创建场景时定义的任务");
        Boolean isSave=jobMapper.insertJob(sysJob);
        if (isSave)
        {
                ScheduleUtils.createScheduleJob(scheduler, sysJob);
        }
        return ResultMap.ok(sysJob.getJobId().toString());
    }
    /**
     * @description:暂停任务
     * @author: sunshangeng
     * @date: 2023/3/1 13:56
     * @param: [id]
     * @return: com.ruoyi.common.core.result.ResultMap
     **/
    public static ResultMap pauseJob(Long id) throws TaskException, SchedulerException {
        SysJob sysJob = jobMapper.selectJobById(id);
        String jobGroup = sysJob.getJobGroup();
        sysJob.setStatus(ScheduleConstants.Status.PAUSE.getValue());
        int rows = jobMapper.updateJob(sysJob);
        if (rows > 0)
        {
            scheduler.pauseJob(ScheduleUtils.getJobKey(id, jobGroup));
        }else{
            return ResultMap.error("未查找到该任务！");

        }
        return ResultMap.ok();
    }

    /***
     * @description:*恢复任务
     * @author: sunshangeng
     * @date: 2023/3/1 13:56
     * @param: [id]
     * @return: com.ruoyi.common.core.result.ResultMap
     */
    public static   ResultMap resumeJob(Long id) throws TaskException, SchedulerException {
        SysJob sysJob = jobMapper.selectJobById(id);
        String jobGroup = sysJob.getJobGroup();
        sysJob.setStatus(ScheduleConstants.Status.PAUSE.getValue());
        int rows = jobMapper.updateJob(sysJob);
        if (rows > 0)
        {
            scheduler.resumeJob(ScheduleUtils.getJobKey(id, jobGroup));
        }else{
            return ResultMap.error("未查找到该任务！");
        }
        return ResultMap.ok();
    }

    /**
     * @description:删除定时任务
     * @author: sunshangeng
     * @date: 2023/3/1 13:56
     * @param: [id]
     * @return: com.ruoyi.common.core.result.ResultMap
     **/
    public static ResultMap deleteJob(Long id) throws SchedulerException
    {
        SysJob sysJob = jobMapper.selectJobById(id);

        String jobGroup = sysJob.getJobGroup();
        int rows = jobMapper.deleteJobById(id);
        if (rows > 0)
        {
            scheduler.deleteJob(ScheduleUtils.getJobKey(id, jobGroup));
        }else{
            return  ResultMap.error("未查找到该任务");
        }
        return ResultMap.ok();
    }


    /**
     * @description:修改任务
     * @author: sunshangeng
     * @date: 2023/3/1 13:50
     * @param: [job, jobGroup]
     * @return: void
     **/
    public static ResultMap updateSchedulerJob(Long id,String cron) throws SchedulerException, TaskException
    {
        /**验证cron表达式 是否正确*/
        if (!CronUtils.isValid(cron))
        {
            return ResultMap.error("失败，Cron表达式不正确");
        }
        SysJob sysJob = jobMapper.selectJobById(id);
        sysJob.setCronExpression(cron);
        int row = jobMapper.updateJob(sysJob);
        if(row>0){
            // 判断是否存在
            JobKey jobKey = ScheduleUtils.getJobKey(id, sysJob.getJobGroup());
            if (scheduler.checkExists(jobKey))
            {
                // 防止创建时存在数据问题 先移除，然后在执行创建操作
                scheduler.deleteJob(jobKey);
            }
            ScheduleUtils.createScheduleJob(scheduler, sysJob);
            return  ResultMap.ok();
        }else{
            return ResultMap.error("修改未成功！");
        }
    }


    /***
     * @description:定时的场景触发方法
     * @author: sunshangeng
     * @date: 2023/3/1 10:20
     * @param: []
     * @return: void
     **/
    public void  SceneLinkJobExecute(){

        System.out.println(1234);
    }


    /**
     * 调试点位
     *
     * @param treeId 点位树id
     * @param value  值
     * @return {@code AjaxResult }
     * @Author qindehua
     * @Date 2023/03/01
     **/
    public static DataReception debugPointInfo(Long treeId, Double value) {

        Integer workMode=1;
        if (treeId == null || value == null) {
            log.error("调试点位参数错误!");
            return new DataReception(false,"参数错误!");
        }

        Controller controllerPoint = null;

        Double accuracy;

        Point pointMap = moduleAndPointCache.getPointByDeviceId(treeId);
        if (pointMap == null || pointMap.getEquipmentId() == null ||
                pointMap.getControllerId() == 0 || pointMap.getNodeType() == null ||
                pointMap.getSysName() == null || pointMap.getWorkMode() == null) {
            log.error("参数错误,点位缓存未获取到点位数据!");
            return new DataReception(false,"参数错误,点位缓存未获取到点位数据!");
        }

        PointDebugLog pointDebugLog = new PointDebugLog();
        pointDebugLog.setCreateTime(DateUtils.getNowDate());
        pointDebugLog.setDeviceTreeId(treeId.intValue());
        pointDebugLog.setSysName(pointMap.getSysName());
        pointDebugLog.setOperatValue(value.toString());
//        if (SecurityUtils.getUsername() == null) {
//            log.error("未获取到操作人信息!");
//            return new DataReception(false,"未获取到操作人信息!");
//        }
//        pointDebugLog.setCreateName(SecurityUtils.getUsername());
        //场景配置 暂无操作人
        pointDebugLog.setCreateName("场景配置");

        //查询该逻辑点所在的控制器的ip
        Collection<Object> values = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_DeviceTree_Controller).values();
        for (Object obj : values) {
            Controller con = (Controller) obj;
            if (con.getId() == pointMap.getControllerId()) {
                controllerPoint = con;
            }
        }

        if (controllerPoint == null || controllerPoint.getIp() == null) {
            log.error("参数错误,控制器缓存未获取到控制器数据!");
            return new DataReception(false,"参数错误,控制器缓存未获取到控制器数据!");
        }

        String id = String.valueOf(pointMap.getEquipmentId());
        String nodeType = pointMap.getNodeType();

        //如果精度不为空或者不为0则进行换算
        Long accuracyLong = pointMap.getAccuracy();
        if (null != accuracyLong && accuracyLong > 0) {
            accuracy = Double.valueOf(String.valueOf(pointMap.getAccuracy()));
            value = value * Math.pow(10, accuracy);
        }


        BigDecimal b = new BigDecimal(value);
        double f1 = b.setScale(0, BigDecimal.ROUND_HALF_UP).doubleValue();
        String aa = String.valueOf(f1);
        Integer v = Integer.parseInt(aa.substring(0, aa.indexOf(".")));

        String channelId = controllerPoint.getIp();

        if (v == null) {
            log.error("请输入值!");
            return new DataReception(false,"请输入值!");
        }
        if (!StringUtils.hasText(channelId) || controllerPoint.getType() == 0) {
            log.error("参数错误,控制器缓存未获取到控制器ip和类型!");
            return new DataReception(false,"参数错误,控制器缓存未获取到控制器ip和类型!");
        }

        if (Integer.parseInt(nodeType) == DeviceTreeConstants.BES_VPOINT) {
            workMode = 0;
        }

        if (controllerPoint.getType().equals(DeviceTreeConstants.BES_DDCNODE)) {//楼控

            PointDataDDC pointData = new PointDataDDC();
            pointData.setId(Integer.valueOf(id));
            pointData.setValue(v);
            pointData.setWorkMode(workMode);
            boolean sendState = SendMsgHandler.setPointValueDDC(channelId, pointData);

            if (!sendState) {
                // 存储操作记录
                pointDebugLog.setDebugState("0");
                pointMapper.addDebugLog(pointDebugLog);
                return new DataReception(false,"下发失败");
            }

            // 添加订阅消息
            MsgSubPubHandler.addSubMsg(DDCCmd.POINT_VALUE_SET, channelId);
            // 存储操作记录
            pointDebugLog.setDebugState("1");
            pointMapper.addDebugLog(pointDebugLog);
            //修改缓存信息工作模式
            if (pointMap.getWorkMode() != workMode.longValue()) {
                pointMap.setWorkMode(workMode.longValue());
                pointMapper.updatePoint(pointMap);
                redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_DeviceTree_Point, treeId, pointMap);
            }
            return new DataReception(true,"下发成功!");

        }
        else if (controllerPoint.getType().equals(DeviceTreeConstants.BES_ILLUMINE)) {//照明

            PointDataLDC pointDataLDC = new PointDataLDC();
            pointDataLDC.setId(Integer.valueOf(id));
            pointDataLDC.setValue(v);
            pointDataLDC.setWorkMode(workMode);
            boolean sendState = SendMsgHandler.setPointValueLDC(channelId, pointDataLDC);

            if (!sendState) {
                // 存储操作记录
                pointDebugLog.setDebugState("0");
                pointMapper.addDebugLog(pointDebugLog);
                return new DataReception(false,"下发失败!");
            }

            // 添加订阅消息
            MsgSubPubHandler.addSubMsg(LDCCmd.POINT_VALUE_SET, channelId);
            // 存储操作记录
            pointDebugLog.setDebugState("1");
            pointMapper.addDebugLog(pointDebugLog);
            //修改缓存信息工作模式
            if (pointMap.getWorkMode() != workMode.longValue()) {
                pointMap.setWorkMode(workMode.longValue());
                pointMapper.updatePoint(pointMap);
                redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_DeviceTree_Point,  treeId, pointMap);
            }
            return new DataReception(true,"下发成功!");
        }

        // 存储操作记录
        pointDebugLog.setDebugState("0");
        pointMapper.addDebugLog(pointDebugLog);
        return new DataReception(false,"下发失败!");
    }

    /**
     * @description:场景触发
     * @author: sunshangeng
     * @date: 2023/3/1 15:50
     * @param: [当前执行的场景id]
     * @return: com.ruoyi.common.core.result.ResultMap
     **/
    public ResultMap ExecuteSceneTrigger(String sceneId){

        if(!StringUtils.hasText(sceneId)){
            return  ResultMap.error("传入的场景id为空！");
        }
//        redisCache.setCacheMapValue(RedisKeyConstants.BES_SceneLink_Trigger,item.getId(),item);

        Map<String, SceneTrigger> cacheMap = redisCache.getCacheMap(RedisKeyConstants.BES_SceneLink_Trigger);
        List<SceneTrigger> triggerList=new ArrayList<>();


        for (SceneTrigger trigger : cacheMap.values()) {
            /**触发执行*/
            if (trigger.getSceneStatus()==1||sceneId.equals(trigger.getTriggerSceneId())) {
                /**记录*/
                try {
                    /**执行执行器内容*/
                    /**获取所有执行器*/

                    SceneActuator actuator = new SceneActuator();
                    actuator.setSceneId(Long.parseLong(sceneId));
                    List<SceneActuator> actuators = actuatorMapper.selectSceneActuatorList(actuator);
                    for (SceneActuator sceneActuator : actuators) {
                        if (sceneActuator.getMovementMode() == 1) {
                            /**消息通知*/
//                            ResultMap resultMap = NoticeHandler.sendNotice(Long.parseLong(sceneActuator.getNoticeConfig())
//                                    , Long.parseLong(sceneActuator.getNoticeTemplate())
//                                    , sceneActuator.getUserIds().split(",")
//                                    , actuator.getContent());
//                            if((int)resultMap.get("code")==0){
//                                /**成功*/
////                              return res
//                            }else{
//                                /**失败*/
////                                return AjaxResult.error(resultMap.get("msg").toString());
//                            }
                        } else {
                            /**设置设备值**/
                            String[] treeids = sceneActuator.getTreeId().split(",");
                            for (int i = 0; i < treeids.length; i++) {
                                SceneLinkHandler.debugPointInfo(Long.parseLong(treeids[i]),Double.parseDouble(sceneActuator.getExecuteValue()));

                            }

                        }
                    }
                }catch (Exception e){
                    e.getStackTrace();
                    log.error("场景执行器执行时发生问题："+e.getMessage());
                }
            }
        }
        return ResultMap.ok();
    }
}
