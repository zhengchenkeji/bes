package com.zc.connect.nettyServer.ChildChannelHandler.ModbusHandler;

import com.ruoyi.common.core.redis.RedisCache;
import com.ruoyi.common.utils.StringUtils;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.connect.business.dto.JsonMsg;
import com.zc.efounder.JEnterprise.domain.baseData.Equipment;
import com.zc.efounder.JEnterprise.domain.baseData.ProductFunction;
import com.zc.efounder.JEnterprise.domain.baseData.ProductItemData;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.Channel;
import io.netty.channel.ChannelId;
import io.netty.util.HashedWheelTimer;
import io.netty.util.TimerTask;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.ConcurrentLinkedQueue;
import java.util.concurrent.TimeUnit;
import java.util.logging.Logger;

/**
 * 下位机消息发送类
 *
 * @author xiepufeng
 * @date 2020/4/15 8:26
 */
@Component
public class ModbusSendSyncMsgHandler {

    private static final Logger log = Logger.getLogger(ModbusSendSyncMsgHandler.class.getName());


    public static HashedWheelTimer timer = new HashedWheelTimer();//时间轮的度刻

    // 消息队列
    public final static Map<String, Queue<JsonMsg>> msgQueue = new HashMap<>();

    @Autowired
    private RedisCache redisCache;


    /**
     * 发送数据到客户端
     *
     * @param channelID 通道id
     * @param jsonMsg   消息体
     * @return
     */
    static boolean postEvent(String channelID, int port, JsonMsg jsonMsg)
    {

        if (channelID == null || channelID.isEmpty() || jsonMsg == null)
        {
            return false;
        }

        /**
         * 添加定时任务，清理队列中的超时任务
         *
         * 3秒后执行定时任务，检查此消息是否回复，
         * 如果队列中消息还存在则说明此消息发送后没有
         * 回复，那么就把此消息弹出消息队列，查看队列
         * 中是否有下一个消息，如果存在则发送出去
         *
         */
        TimerTask task = timeout ->
        {

            String uuid = jsonMsg.getUuid();

            Queue<JsonMsg> queue = msgQueue.get(channelID + ":" + port);

            if (queue == null || queue.isEmpty())
            {
                return;
            }

            JsonMsg queueMsg = queue.peek();

            if (queueMsg == null)
            {
                return;
            }

            if (uuid.equals(queueMsg.getUuid()))
            {
                // 如果该消息还没有回复，则清除该消息
                queue.poll();

                JsonMsg nextMsg = queue.peek();

                if (nextMsg == null)
                {
                    return;
                }

                postEvent(channelID, port, nextMsg);

            }
        };

        // 三秒后执行定时任务
        timer.newTimeout(task, 10, TimeUnit.SECONDS);

        ChannelId channelId = ServerHandler_modbus.channels.get(channelID + ":" + port);
        Channel channel = ServerHandler_modbus.clients.find(channelId);

        if (channel == null)
        {
            log.warning("Post event failed, because the channel for event subscriber:" + channelID + " is not exists");
            return false;
        }

        ByteBuf msg = (ByteBuf) jsonMsg.getData();

//        msg = CrcUtil.addVerifyCRC(msg);

        channel.writeAndFlush(msg);

        return true;
    }

    /**
     * 发送数据到客户端
     *
     * @param channelID 通道id
     * @param jsonMsg   消息体
     * @return
     */
    static boolean sendEvent(String channelID, JsonMsg jsonMsg)
    {

        if (channelID == null || channelID.isEmpty() || jsonMsg == null)
        {
            return false;
        }

        ChannelId channelId = ServerHandler_modbus.channels.get(channelID);
        Channel channel = ServerHandler_modbus.clients.find(channelId);

        if (channel == null)
        {
            log.warning("Post event failed, because the channel for event subscriber:" + channelID + " is not exists");
            return false;
        }

        ByteBuf msg = (ByteBuf) jsonMsg.getData();

//        msg = CrcUtil.addVerifyCRC(msg);

        channel.writeAndFlush(msg);

        return true;
    }



    /**
     * 消息入栈等待发送
     *
     * 1.判断通告是否存在，不存在则返回 false
     * 2.如果该通道没有消息队列，则创建
     * 3.如果消息队列中没有消息则直接发送消息
     * 4.把消息添加到消息队列
     * @param channelID
     * @param jsonMsg
     * @return
     */
    public static boolean pushStack(String channelID, int port, JsonMsg jsonMsg)
    {

        if (channelID == null || channelID.isEmpty() || jsonMsg == null)
        {
            return false;
        }

        ChannelId channelId = ServerHandler_modbus.channels.get(channelID + ":" + port);
        if (channelId == null) {
            return false;
        }
        Channel channel = ServerHandler_modbus.clients.find(channelId);

        Queue<JsonMsg> queue = msgQueue.computeIfAbsent(channelID + ":" + port, k -> new ConcurrentLinkedQueue<>());

        if (channel == null)
        {
            queue.clear();
            log.warning("Post event failed, because the channel for event subscriber:" + channelID + " is not exists");
            return false;
        }

        if (queue.isEmpty())
        {
            if (!ModbusSendSyncMsgHandler.postEvent(channelID, port, jsonMsg))
            {
                return false;
            }
        }

        return queue.offer(jsonMsg);
    }

    /**
     * @Description: 发送给modbus服务端消息(网关设备)
     * @auther: wanghongjie
     * @date: 9:02 2023/3/15
     * @param: [equipment, host, port]
     * @return: void
     */
    public void sendModbusGatewaySyncMsg(Equipment equipment, String host, Integer port) {

        //获取当前产品下所有的设备
        Map<String, Equipment> equipmentList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

        List<Equipment> equipmentLists = new ArrayList<>();

        equipmentList.values().forEach(val1 -> {
            if (val1.getpId() == null) {
                return;
            }
            if (!val1.getpId().equals(equipment.getId())) {
                return;
            }
            equipmentLists.add(val1);


        });

        if (equipmentLists == null || equipmentLists.size() == 0) {//当前网关下没有子设备

            return;
        }

        //获取设备所有的数据项
        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

        //网关设备
        equipmentLists.forEach(val -> {
            try {
                issued(host,port,val,productItemDataList);
            } catch (NoSuchAlgorithmException e) {
                e.printStackTrace();
            }
        });

    }

    /**
     * @Description: 发送给modbus服务端消息(直连设备)
     * @auther: wanghongjie
     * @date: 9:02 2023/3/15
     * @param: [equipment, host, port]
     * @return: void
     */
    public void sendModbusDirectConnectionSyncMsg(Equipment val, String host, Integer port) throws NoSuchAlgorithmException {


        //获取设备所有的数据项
        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

        issued(host,port,val,productItemDataList);
    }


    public void issued(String host, Integer port, Equipment val, Map<String, ProductItemData> productItemDataList) throws NoSuchAlgorithmException {
        Map<Integer, List<ProductItemData>> productItemDataMap = new HashMap<>();
        productItemDataList.values().forEach(val2 -> {
            if (val2.getProductId() == val.getProductId()) {

                if (!productItemDataMap.containsKey(Integer.valueOf(val2.getFunctionCode()))) {//当前key不存在
                    List<ProductItemData> productItemData = new ArrayList<>();
                    productItemData.add(val2);
                    productItemDataMap.put(Integer.valueOf(val2.getFunctionCode()), productItemData);
                } else {
                    List<ProductItemData> productItemData = productItemDataMap.get(Integer.valueOf(val2.getFunctionCode()));
                    productItemData.add(val2);
                }
            }

        });

        Set<Integer> keys = productItemDataMap.keySet();
        for (Integer key : keys) {//遍历功能码

            List<ProductItemData> productItemData = productItemDataMap.get(key);
            if (productItemData.size() != 0) {
                Collections.sort(productItemData, new Comparator<ProductItemData>() {
                    @Override
                    public int compare(ProductItemData o1, ProductItemData o2) {
                        return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                    }
                });


                //获取起始字节
                int beginByte = productItemData.get(0).getSortNum().intValue();
                //获取读取的字节数
                int byteSize = productItemData.get(productItemData.size() - 1).getSortNum().intValue();
                //获取设备地址
                int slaveId = val.getSonAddress().intValue();
                //netty需要用ByteBuf传输
                ByteBuf byteBuf = Unpooled.buffer();

                // 创建 SecureRandom 对象，并设置加密算法
                SecureRandom random = SecureRandom.getInstance("SHA1PRNG");

                int TransActionId = random.nextInt(65535);
                int protocal = random.nextInt(65535);
                byteBuf.writeShort(TransActionId);//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。
                byteBuf.writeShort(protocal);//协议标识：2个字节 表示该条指令遵循ModbusTCP协议，一般都为00 00
                byteBuf.writeShort(6);//报文长度：2个字节 表示后面数据的长度，有几个字节，高字节在前
                byteBuf.writeByte(slaveId);//设备标识 1个字节
                byteBuf.writeByte(3);//功能码 1个字节
                byteBuf.writeShort(beginByte);//起始地址
                byteBuf.writeShort(byteSize + 1);//读取多少个数据

                JsonMsg jsonMsg = new JsonMsg();

                jsonMsg.setUuid(String.valueOf(TransActionId) + String.valueOf(protocal));
                jsonMsg.setData(byteBuf);
                jsonMsg.setRegisterBeginAddress(beginByte);
                jsonMsg.setRegisterLength(byteSize + 1);
                pushStack(host , port, jsonMsg);

            }
        }
    }

    /**
     *
     * @Description:
     *
     * @auther: wanghongjie
     * @date: 17:55 2023/3/27
     * @param: [host, port, val]
     * @return: void
     *
     */
    public void issued1(String host, Integer port, Equipment val, Long functionId) {

        Integer functionCode = null;

        if (StringUtils.isEmpty(host) || port == null || functionId == null) {
            return;
        }
        //获取设备所有的数据项
        ProductFunction productFunction = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_Function,functionId);

        String type = productFunction.getType();//功能类型;0-控制;1-采集;

        String issuedType = productFunction.getIssuedType();//下发方式;0-指令下发;1-数据项下发

        if (type == null || issuedType == null) {
            return;
        }
        if (type.equals("0")) {

        }



    }
}
