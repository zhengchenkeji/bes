package com.zc.connect.nettyClient.ClientHandlers;

import com.ruoyi.common.core.redis.RedisCache;
import com.zc.ApplicationContextProvider;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.common.core.ThreadPool.ThreadPool;
import com.zc.connect.config.SyncFuture;
import com.zc.connect.nettyClient.NettyClient;
import com.zc.efounder.JEnterprise.domain.baseData.Equipment;
import com.zc.efounder.JEnterprise.domain.baseData.ProductItemData;
import com.zc.efounder.JEnterprise.domain.deviceTree.NodeConfigSet;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.net.InetSocketAddress;
import java.util.*;

/**
 * @Author: wanghongjie
 * @Description:
 * @Date: Created in 14:01 2023/2/23
 * @Modified By:
 */
@Component
public class ModbusClientHandlers {
    private static final Logger log = LoggerFactory.getLogger(ModbusClientHandlers.class);

    //redis
    private RedisCache redisCache = ApplicationContextProvider.getBean(RedisCache.class);

    /**
     * 回令业务处理
     * 解析
     */
    public void response_analysis(ChannelHandlerContext ctx, Object msg) {


        String host = ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress();
        int post = ((InetSocketAddress) ctx.channel().remoteAddress()).getPort();

        //遍历配置产品,取出所有的网关设备(tcp)
        List<Equipment> equipmentList = NettyClient.getEquipmentTCPList();
        if (equipmentList.size() == 0) {
            return;
        }

        equipmentList.forEach(val -> {

            String HOST = val.getIpAddress();
            Integer PORT = Integer.parseInt(val.getPortNum());

            //获取当前产品下所有的设备
            Map<String, Equipment> equipmentLists = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);
            equipmentLists.values().forEach(val1 -> {
                if (val1.getpId() != null) {
                    if (val1.getpId().equals(val.getId())) {
                        //获取设备所有的数据项
                        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);


                        List<ProductItemData> productItemDataLists = new ArrayList<>();
                        productItemDataList.values().forEach(val2 -> {
                            if (val2.getProductId() == val.getProductId()) {
                                productItemDataLists.add(val2);
                            }

                        });

                        if (productItemDataLists.size() != 0) {
                            Collections.sort(productItemDataLists, new Comparator<ProductItemData>() {
                                @Override
                                public int compare(ProductItemData o1, ProductItemData o2) {
                                    return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                                }
                            });

                            //获取起始字节
                            int beginByte = productItemDataLists.get(0).getSortNum().intValue();
                            //获取读取的字节数
                            int byteSize = productItemDataLists.size();
                            //获取设备地址
                            int slaveId = val1.getSonAddress().intValue();
                        }



                    }
                }
            });
        });

        String ip_port = host + ":" + post;
        //根据当前ip获取对应的消息解析方式
        System.out.println(ip_port);
        ByteBuf byteBuf = (ByteBuf) msg;

//        System.out.println("---------------start process msg--------------------");
//        System.out.println("readable bytes is:"+byteBuf.readableBytes());
        short TransActionId = byteBuf.readShort();
        short protocal = byteBuf.readShort();
        short msg_len = byteBuf.readShort();
        byte slave_id = byteBuf.readByte();
        byte funcotion_code = byteBuf.readByte();

        if (funcotion_code == 3)//如果功能码是4，也就是读请求，我们要返回结果
        {   //输出
            short start_address = byteBuf.readByte();
            short ncount = byteBuf.readShort();
//            System.out.println("TransactionID is:"+ TransActionId);
//            System.out.println("protocal id is:"+protocal);
//            System.out.println("msg len is:"+msg_len);
//            System.out.println("slave id  is:"+slave_id);
//            System.out.println("function code is:"+funcotion_code);
//            System.out.println("start address is:"+start_address);
//            System.out.println("count  is:"+ncount);
            System.out.println("------------------------------------------------");

//            ByteBuf out = ctx.alloc().directBuffer(110);
//            out.writeShort(TransActionId);//Transaction ID  2
//            out.writeShort(protocal);//protocal id     2
//            out.writeShort(6);//msg len        2
//            out.writeByte(slave_id + 1);//slave id         1
//            out.writeByte(6);//function code    1
//            //out.writeShort(0);//start address 2
//            out.writeShort(0);//46个寄存器      46*2
//
//            int[] buffer = new int[2];
//            buffer[1] = 13;
//
//            for(int i=0;i<buffer.length;i++) {
//                out.writeByte(buffer[i]);
//            }
//
//
//
//            ctx.channel().writeAndFlush(out);
        }


    }
}
