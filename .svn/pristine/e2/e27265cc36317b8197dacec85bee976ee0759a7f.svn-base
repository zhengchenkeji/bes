package com.zc.connect.nettyServer.ChildChannelHandler.ModbusHandler;

import com.ruoyi.common.constant.ModbusFunctions;
import com.ruoyi.common.core.redis.RedisCache;
import com.zc.ApplicationContextProvider;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.connect.business.dto.JsonMsg;
import com.zc.connect.business.handler.ModbusMsgReceive;
import com.zc.connect.config.CodeConfig;
import com.zc.connect.nettyClient.ClientHandler;
import com.zc.connect.util.MsgUtil;
import com.zc.connect.util.StringUtil;
import com.zc.efounder.JEnterprise.domain.baseData.Equipment;
import com.zc.efounder.JEnterprise.domain.baseData.Product;
import com.zc.efounder.JEnterprise.domain.baseData.ProductItemData;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.net.InetSocketAddress;
import java.util.*;

/**
 * @Author: wanghongjie
 * @Description:
 * @Date: Created in 9:16 2023/3/9
 * @Modified By:
 */
@Component
public class ModbusServerHandlers {
    private static final Logger log = LoggerFactory.getLogger(ModbusServerHandlers.class);

    private static List<Product> productLists = new ArrayList<>();

    private static List<Equipment> equipmentTCPList = new ArrayList<>();

    //redis
    private RedisCache redisCache = ApplicationContextProvider.getBean(RedisCache.class);

    /**
     * 回令业务处理
     * 解析
     */
    public void response_analysis(ChannelHandlerContext ctx, Object msg) throws Exception {

        JsonMsg jsonMsg = new JsonMsg();

        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;

        refreshDevice();

        String host = ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress();
        int post = ((InetSocketAddress) ctx.channel().remoteAddress()).getPort();


        ByteBuf byteBuf = (ByteBuf) msg;

        String msgs = MsgUtil.convertByteBufToString(byteBuf);

        byteBuf.release();

        if (msgs.equals(CodeConfig.UsrHeartbeat)) {//有人模块的心跳
            //返回响应消息报文
            byte[] bytes = msgs.getBytes(CharsetUtil.UTF_8);
            ByteBuf buf = Unpooled.wrappedBuffer(bytes);
            ctx.channel().writeAndFlush(buf);

            return;
        }

        int TransActionId = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(0, 4)));//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。
        int protocal = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(4, 8)));//协议标识：2个字节 表示该条指令遵循ModbusTCP协议，一般都为00 00
        int msg_len = Integer.valueOf(msgs.substring(8, 12));//报文长度：2个字节 表示后面数据的长度，有几个字节，高字节在前
        int slave_id = Integer.valueOf(msgs.substring(12, 14));//设备标识 1个字节
        int funcotion_code = Integer.valueOf(msgs.substring(14, 16));//功能码 1个字节

        Integer registerBeginAddress = null;////寄存器起始地址

        Integer registerLength = null;//寄存器数量

        Queue<JsonMsg> queue = ModbusSendSyncMsgHandler.msgQueue.get(host + ":" + post);

        if (queue != null && queue.size() > 0) {

            JsonMsg queueMsg = queue.peek(); // 返回队首元素，但是不删除。

            if ((String.valueOf(TransActionId) + protocal).equals(queueMsg.getUuid())) {
                registerBeginAddress = queueMsg.getRegisterBeginAddress();
                registerLength = queueMsg.getRegisterLength();
            }

        }


        jsonMsg.setUuid(String.valueOf(TransActionId) + protocal);
        jsonMsg.setIp(host);
        jsonMsg.setPost(post);
        msgReceiptHandler(jsonMsg);

//        if (1 == 1) {
//            return;
//        }


        //判断功能码是否正确
        //可参考网址:https://blog.csdn.net/weixin_46304253/article/details/107960184?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&utm_relevant_index=17
        if (funcotion_code != ModbusFunctions.COIL_STATUS &&
                funcotion_code != ModbusFunctions.INPUT_STATUS &&
                funcotion_code != ModbusFunctions.HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.INPUT_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_ONE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_ONE_HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {

            return;
        }

        if (funcotion_code == ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {
            //控制指令下发成功
            clientMsgReceive.sendMessageBoolen(true);
            return;
        }

        //遍历配置产品,取出所有的网关设备(tcp)
        List<Equipment> equipmentList = getEquipmentTCPList();
        if (equipmentList.size() == 0) {
            return;
        }

        try {
            Long equipmentId = null;

            for (Equipment equipment : equipmentList) {
                String HOST = equipment.getIpAddress();
                Integer PORT = Integer.parseInt(equipment.getPortNum());
                if (!host.equals(HOST) || post != PORT) {
                    continue;
                }
                equipmentId = equipment.getId();
            }

            if (equipmentId == null) {
                return;
            }

            //获取当前产品下所有的设备
            Long productId = null;
            Map<String, Equipment> equipmentLists =
                    redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

            for (Equipment equipment : equipmentLists.values()) {
                if (equipment.getpId() == null) {//网关设备或者直连设备
                    continue;
                }
                if (!equipment.getpId().equals(equipmentId)) {//判断设备的父节点是否等于网关设备或者直连设备
                    continue;
                }
                if (equipment.getSonAddress().intValue() != slave_id) {//子设备地址是否为推送的地址
                    continue;
                }

                //websocket推送设备在线离线状态

                clientMsgReceive.deviceState(host, post, equipment.getId(), true);

                productId = equipment.getProductId();

            }

            //获取设备所有的数据项
            Map<String, ProductItemData> productItemDataList =
                    redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

            List<ProductItemData> productItemDataLists = new ArrayList<>();
            for (ProductItemData productItemData : productItemDataList.values()) {
                if (productItemData.getProductId() != productId) {//判断数据项的产品id是否等于设备的产品id
                    continue;
                }
                productItemDataLists.add(productItemData);
            }

            Collections.sort(productItemDataLists, new Comparator<ProductItemData>() {
                @Override
                public int compare(ProductItemData o1, ProductItemData o2) {
                    return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                }
            });
            Integer byteLength = Integer.valueOf(msgs.substring(16, 17));//字节数

            Integer lestLength = msgs.substring(17, msgs.length() - 1).length();


            if (lestLength % 4 != 0) {//不能被4整除,说明回复的消息有误,数据不完整
                clientMsgReceive.getMassgaeState(host, post,  0, "获取数据不完整");
                return;
            } else {
                if (registerLength != (lestLength / 4)) {//发送的寄存器数量和回复的寄存器数量不相等,说明数据不完整
                    clientMsgReceive.getMassgaeState(host, post,  0, "获取数据不完整");
                    return;
                }
            }

            int size = 0;

            for (ProductItemData productItemData : productItemDataLists) {
                if (size > registerLength) {
                    continue;
                }

                if (productItemData.getSortNum().intValue() < registerBeginAddress) {
                   continue;
                }



                double x = 10;

                double y = size;

                Integer numByten = 4 * size;

                size = size + 1;

                String highLow = productItemData.getHighLow();//高低位 0-否;1-是;

                String binarySystem = productItemData.getBinarySystem();//二进制 0-否;1-是;

//                int readByteLength = productItemData.getByteLength().intValue();//获取读取的字节长度

                int dataType = Integer.valueOf(productItemData.getDataType());//数据类型

                int ratioSize = Integer.valueOf(productItemData.getRatioSize());//比率
//
                int radixPoint = Integer.valueOf(productItemData.getRadixPoint());//小数点位置

                ;

                //todo 目前先不判断高低位中有2进制数据
                //判断是否高低位
                if (highLow.equals("1")){//是

                    //获取高位数据项

                    Integer highData = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(18 + numByten, 20 + numByten)));//高位数据
                    highData = highData * ratioSize;
                    highData = highData / ((int) Math.pow(10,(double) radixPoint));
                    System.out.println(highData);

                    //获取低位数据项


                    Integer lowData = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(20 + numByten, 22 + numByten)));//高位数据
                    lowData = lowData * ratioSize;
                    lowData = lowData / ((int) Math.pow(10,(double) radixPoint));
                    System.out.println(lowData);
                    continue;
                }



                //判断数据类型
                 if (dataType == 8) {//结构体

                } else {
                     Integer dataValue = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(18 + numByten, 22 + numByten)));//高位数据
                     dataValue = dataValue * ratioSize;
                     dataValue = dataValue / ((int) Math.pow(10,(double) radixPoint));
                     System.out.println(dataValue);
                }






            }


//            Set<Integer> keys = productItemDataMap.keySet();
//            for (Integer key : keys) {
//                if (key != funcotion_code) {
//                    continue;
//                }
//                List<ProductItemData> productItemData = productItemDataMap.get(key);
//                if (productItemData.size() == 0) {
//                    continue;
//                }
//
//                Collections.sort(productItemData, new Comparator<ProductItemData>() {
//                    @Override
//                    public int compare(ProductItemData o1, ProductItemData o2) {
//                        return o1.getSortNum().intValue() - o2.getSortNum().intValue();
//                    }
//                });
//
//                //获取当前功能码第一个寄存器地址
//                Integer firstByteNum = productItemData.get(0).getSortNum().intValue();
//                productItemData.forEach(val -> {
//                    Integer byteNum = val.getSortNum().intValue();//寄存器地址
//
////                        Short s = shortList.get(byteNum - firstByteNum);
////                        val.setDataValue(BigDecimal.valueOf(s));
////                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
////                        System.out.println(s);
//                });
//            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        //判断当前协议类型,是tcp或者udp

//        ModbusMsgReceive modbusMsgReceive = ClientHandler.modbusMsgReceive;
//        modbusMsgReceive.sendRegistrationMessage("1");


      /*  ThreadPool.executor.execute(() -> {
            //遍历配置产品,取出所有的网关设备(tcp)
            List<Equipment> equipmentList = getEquipmentTCPList();
            if (equipmentList.size() == 0) {
                return;
            }
            try {

                equipmentList.forEach(val -> {

                    String HOST = val.getIpAddress();
                    Integer PORT = Integer.parseInt(val.getPortNum());
                    if (!host.equals(HOST) || 9001 != PORT) {
                        return;
                    }

                    //获取当前产品下所有的设备
                    Map<String, Equipment> equipmentLists = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);
                    equipmentLists.values().forEach(val1 -> {
                        if (val1.getpId() == null) {//网关设备或者直连设备
                            return;
                        }
                        if (!val1.getpId().equals(val.getId())) {
                            return;
                        }
                        if (val1.getSonAddress().intValue() != slave_id) {
                            return;
                        }

                        //websocket推送设备在线离线状态
                        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;
                        clientMsgReceive.deviceState(host, 9001, val1.getId(), true);

                        //获取设备所有的数据项
                        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

                        productItemDataList.values().forEach(val2 -> {
                            if (val2.getProductId() != val1.getProductId()) {
                                return;
                            }
                            if (!productItemDataMap.containsKey(Integer.valueOf(val2.getFunctionCode()))) {//当前key不存在
                                List<ProductItemData> productItemData = new ArrayList<>();
                                productItemData.add(val2);
                                productItemDataMap.put(Integer.valueOf(val2.getFunctionCode()), productItemData);
                            } else {
                                List<ProductItemData> productItemData = productItemDataMap.get(Integer.valueOf(val2.getFunctionCode()));
                                productItemData.add(val2);
                            }
                        });
                    });
                });

                Set<Integer> keys = productItemDataMap.keySet();
                for (Integer key : keys) {
                    if (key != funcotion_code) {
                        continue;
                    }
                    List<ProductItemData> productItemData = productItemDataMap.get(key);
                    if (productItemData.size() == 0) {
                        continue;
                    }

                    Collections.sort(productItemData, new Comparator<ProductItemData>() {
                        @Override
                        public int compare(ProductItemData o1, ProductItemData o2) {
                            return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                        }
                    });

                    //获取当前功能码第一个寄存器地址
                    Integer firstByteNum = productItemData.get(0).getSortNum().intValue();
                    productItemData.forEach(val -> {
                        Integer byteNum = val.getSortNum().intValue();//寄存器地址

//                        Short s = shortList.get(byteNum - firstByteNum);
//                        val.setDataValue(BigDecimal.valueOf(s));
//                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
//                        System.out.println(s);
                    });
                }
            } catch (Exception e) {
                e.printStackTrace();
            }


        });*/
    }


    //刷新设备
    public void refreshDevice() {

        getProductLists().clear();
        equipmentTCPList.clear();

        //遍历配置产品,取出所有的网关设备(tcp)
        Map<String, Product> productList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product);
        if (productList == null || productList.size() == 0) {
            return;
        }

        productList.values().forEach(val -> {
            if (val.getIotType().equals("0") || val.getIotType().equals("1")) {//直连设备或者网关设备
                getProductLists().add(val);
            }
        });

        if (getProductLists().size() == 0) {
            return;
        }

        Map<String, Equipment> controllerList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

        if (controllerList == null || controllerList.size() == 0) {
            return;
        }

        controllerList.values().forEach(val -> {
            if (val.getNetworkType() == null) {
                return;
            }
            if (!val.getNetworkType().equals("0")) {//0-下位机客户端;1-下位机服务端
                return;
            }
            getProductLists().forEach(val1 -> {
                if (val1.getId() == val.getProductId()) {
                    equipmentTCPList.add(val);
                }
            });

        });
    }


    /**
     * 消息回执处理
     * 1.根据通道id获取消息队列
     * 2.获取队列中的消息
     * 3.如果消息是队列中的回复消息，则弹出该消息队列
     * 4.如果队列中有下一个消息则直接发送
     *
     * @param msg
     */
    public static void msgReceiptHandler(JsonMsg msg) {
        if (msg == null) {
            return;
        }

        String uuid = msg.getUuid();
        String ip = msg.getIp();
        Integer port = msg.getPost();

        if (uuid == null || uuid.isEmpty() || ip == null || ip.isEmpty()) {
            return;
        }

        Queue<JsonMsg> queue = ModbusSendSyncMsgHandler.msgQueue.get(ip + ":" + port);

        if (queue == null || queue.isEmpty()) {
            return;
        }

        JsonMsg queueMsg = queue.peek(); // 返回队首元素，但是不删除。

        if (uuid.equals(queueMsg.getUuid())) {
            queue.poll(); // 从队首删除并返回该元素

            JsonMsg nextMsg = queue.peek();

            if (nextMsg == null) {
                return;
            }

            ModbusSendSyncMsgHandler.postEvent(ip, port, nextMsg);
        } else {
            ModbusSendSyncMsgHandler.postEvent(ip, port, queueMsg);
        }

    }

    public static List<Product> getProductLists() {
        return productLists;
    }

    public static void setProductLists(List<Product> productLists) {
        ModbusServerHandlers.productLists = productLists;
    }

    public static List<Equipment> getEquipmentTCPList() {
        return equipmentTCPList;
    }

    public static void setEquipmentTCPList(List<Equipment> equipmentTCPList) {
        ModbusServerHandlers.equipmentTCPList = equipmentTCPList;
    }
}
