package com.zc.connect.nettyClient.ClientHandlers;

import com.ruoyi.common.constant.AcrelCommandCode;
import com.ruoyi.common.constant.AcrelDeviceTypeCode;
import com.ruoyi.common.core.redis.RedisCache;
import com.zc.ApplicationContextProvider;
import com.zc.connect.business.handler.ModbusMsgReceive;
import com.zc.connect.nettyClient.ClientHandler;
import com.zc.connect.util.MsgUtil;
import com.zc.connect.util.StringUtil;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.net.InetSocketAddress;

/**
 * @Author: wanghongjie
 * @Description:
 * @Date: Created in 14:01 2023/2/23
 * @Modified By:
 */
@Component
public class ModbusClientHandlers {
    private static final Logger log = LoggerFactory.getLogger(ModbusClientHandlers.class);

    //redis
    private RedisCache redisCache = ApplicationContextProvider.getBean(RedisCache.class);

    ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;

    /**
     * 回令业务处理
     * 解析
     */
    public void response_analysis(ChannelHandlerContext ctx, Object msg) {
        ByteBuf byteBuf = (ByteBuf) msg;

        String msgs = MsgUtil.convertByteBufToString(byteBuf);


        String host = ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress();
        int post = ((InetSocketAddress) ctx.channel().remoteAddress()).getPort();


        String TransActionId = msgs.substring(0, 4);//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。

//        short TransActionId = byteBuf.readShort();//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。
//        short protocal = byteBuf.readShort();//协议标识：2个字节 表示该条指令遵循ModbusTCP协议，一般都为00 00
//        short protocal = byteBuf.readByte();//控制码


        if ("55AA".equalsIgnoreCase(TransActionId)) {//acrel自定义协议


            //获取设备类型
            String deviceTypeCode = msgs.substring(14, 16);

            //获取命令码
            String CommandCode = msgs.substring(16, 18);

            if ((deviceTypeCode.equalsIgnoreCase(AcrelDeviceTypeCode.IP_PROTOCOL_CONVERTER) &&//42  IP协议转换器
                    CommandCode.equalsIgnoreCase(AcrelCommandCode.HEART_BEAT))//  6  心跳
                    ||
                    (deviceTypeCode.equalsIgnoreCase(AcrelDeviceTypeCode.HOST_DEVICE) &&// 10  主机设备
                            CommandCode.equalsIgnoreCase(AcrelCommandCode.READ_GROUP_OBJECT_STATUS))//89  读取组对象状态
                    ||
                    (deviceTypeCode.equalsIgnoreCase(AcrelDeviceTypeCode.HOST_DEVICE) &&//10 主机设备
                            CommandCode.equalsIgnoreCase(AcrelCommandCode.ACTION_GROUP_OBJECT))//88 操作组对象
            ) {//心跳

                acrelReturnInstructions(ctx);
            }


            //判断传感器指令动作
            if (deviceTypeCode.equalsIgnoreCase(AcrelDeviceTypeCode.SENSOR) &&  //30 传感器
                    CommandCode.equalsIgnoreCase(AcrelCommandCode.ACTION_GROUP_OBJECT)) {// 88 操作组对象


                acrelReturnInstructions(ctx);
            }
            //获取光照度值
            if (deviceTypeCode.equalsIgnoreCase(AcrelDeviceTypeCode.SENSOR) &&  //30 传感器
                    CommandCode.equalsIgnoreCase(AcrelCommandCode.HEART_BEAT)) {// 06 心跳

                acrelReturnInstructions(ctx);
            }


            return;

//            int TransActionId1 = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(0, 4)));//帧起始符 acrel默认55AA(16进制)
//            int protocal1 = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(4, 6)));//控制码 做组地址和物理地址时,数据不一样,都是八位2进制,组地址Bit7 默认0; 物理地址Bit7默认1;  心跳默认80(十六进制)
//            int protocal2= Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(6, 10)));//源物理地址 主机端物理地址 0xFF FF，广播物理地址定义为 0x00 00，网关物理地址定义为 0xXXFF(0x01 FF、0x02 FF)可以理解为ip协议转换器的物理地址
//
//            int protocal3= Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(10, 14)));//目标地址 根据控制码判定物理地址或组地址，高地址位在前，低地址位在后 可以理解为根据控制码不同,
//            // 主机端物理地址 0xFF FF 广播物理地址定义为 0x00 00，网关物理地址定义为 0xXXFF(0x01 FF、0x02 FF)
//            int protocal4= Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(14, 16)));//设备类型 0x00 调试工具 0x10 调光控制主机（主从模块）0x20 开关面 0x30 传感器 0x40 上位机 0x41 网关 0x42 IP 协议转换器 0x50 触摸屏
//            int protocal5= Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(16, 18)));//命令码 //06H 心跳包


//            if (protocal5 == 6) {//心跳
//                //返回响应消息报文
//                //netty需要用ByteBuf传输
//                ByteBuf byteBufs = Unpooled.buffer();
//                byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("55")));
//                byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("bb")));
//                byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("1")));
//                byteBufs.writeShort(Integer.valueOf(StringUtil.hexToDecimal("0")));
//                byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("20")));
//                ctx.channel().writeAndFlush(byteBufs);
//            }
        } else if ("55BB".equalsIgnoreCase(TransActionId)) {

            acrelReturnInstructions(ctx);
            return;
        } else {

            acrelReturnInstructions(ctx);
            return;
        }

//        byte msg_len = byteBuf.readShort();//报文长度：2个字节 表示后面数据的长度，有几个字节，高字节在前
//        byte slave_id = byteBuf.readByte();//设备标识 1个字节
//        byte funcotion_code = byteBuf.readByte();//功能码 1个字节
//        byte byte_msg_len = byteBuf.readByte();//高低字节报文长度 1个字节
//
//        //判断功能码是否正确
//        //可参考网址:https://blog.csdn.net/weixin_46304253/article/details/107960184?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&utm_relevant_index=17
//        if (funcotion_code != ModbusFunctions.COIL_STATUS &&
//                funcotion_code != ModbusFunctions.INPUT_STATUS &&
//                funcotion_code != ModbusFunctions.HOLDING_REGISTER &&
//                funcotion_code != ModbusFunctions.INPUT_REGISTER &&
//                funcotion_code != ModbusFunctions.WRITE_ONE_COIL &&
//                funcotion_code != ModbusFunctions.WRITE_ONE_HOLDING_REGISTER &&
//                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_COIL &&
//                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {
//
//            return;
//        }
//
//        if (msg_len != byte_msg_len + 3) {//功能码错误或者存在粘包问题
//            return;
//        }
//
//
//        if (funcotion_code == 6) {//控制指令
//            //控制指令下发成功
//            clientMsgReceive.sendMessageBoolen(true);
//            return;
//        }
//        List<Short> shortList = new ArrayList<>();
//        for (int i = 0; i < byte_msg_len / 2; i++) {
//            int surplusByteBuf = byteBuf.readableBytes();
//            if (surplusByteBuf == 0) {
//                return;
//            }
//
//            shortList.add(byteBuf.readShort());
//        }
//
//        //功能码和数据项键值对
//        Map<Integer, List<ProductItemData>> productItemDataMap = new HashMap<>();
//
//
//
//
//        ThreadPool.executor.execute(() -> {
//
//            //遍历配置产品,取出所有的网关设备(tcp)
//            List<Equipment> equipmentList = NettyClient.getEquipmentTCPList();
//            if (equipmentList.size() == 0) {
//                return;
//            }
//            try {
//                equipmentList.forEach(val -> {
//
//                    String HOST = val.getIpAddress();
//                    Integer PORT = Integer.parseInt(val.getPortNum());
//                    if (!host.equals(HOST) || post != PORT) {
//                        return;
//                    }
//
//                    //获取当前产品下所有的设备
//                    Map<String, Equipment> equipmentLists = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);
//                    equipmentLists.values().forEach(val1 -> {
//                        if (val1.getpId() == null) {//网关设备或者直连设备
//                            return;
//                        }
//                        if (!val1.getpId().equals(val.getId())) {
//                            return;
//                        }
//                        if (val1.getSonAddress().intValue() != slave_id) {
//                            return;
//                        }
//
//                        //websocket推送设备在线离线状态
//
//                        clientMsgReceive.deviceState(host, post, val1.getId(), true);
//
//                        //获取设备所有的数据项
//                        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);
//
//                        productItemDataList.values().forEach(val2 -> {
//                            if (val2.getProductId() != val1.getProductId()) {
//                                return;
//                            }
//                            if (!productItemDataMap.containsKey(Integer.valueOf(val2.getFunctionCode()))) {//当前key不存在
//                                List<ProductItemData> productItemData = new ArrayList<>();
//                                productItemData.add(val2);
//                                productItemDataMap.put(Integer.valueOf(val2.getFunctionCode()), productItemData);
//                            } else {
//                                List<ProductItemData> productItemData = productItemDataMap.get(Integer.valueOf(val2.getFunctionCode()));
//                                productItemData.add(val2);
//                            }
//                        });
//                    });
//                });
//
//                Set<Integer> keys = productItemDataMap.keySet();
//                for (Integer key : keys) {
//                    if (key != funcotion_code) {
//                        continue;
//                    }
//                    List<ProductItemData> productItemData = productItemDataMap.get(key);
//                    if (productItemData.size() == 0) {
//                        continue;
//                    }
//
//                    Collections.sort(productItemData, new Comparator<ProductItemData>() {
//                        @Override
//                        public int compare(ProductItemData o1, ProductItemData o2) {
//                            return Integer.valueOf(o1.getSortNum().intValue()) - Integer.valueOf(o2.getSortNum().intValue());
//                        }
//                    });
//
//                    //获取当前功能码第一个寄存器地址
//                    Integer firstByteNum = Integer.valueOf(productItemData.get(0).getSortNum().intValue());
//                    productItemData.forEach(val -> {
//                        Integer byteNum = Integer.valueOf(val.getSortNum().intValue());//寄存器地址
//
//                        Short s = shortList.get(byteNum - firstByteNum);
//                        val.setDataValue(BigDecimal.valueOf(s));
//                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
//                        System.out.println(s);
//                    });
//
//                    //设备实时数据  websocket推送到前端
//                    clientMsgReceive.deviceRealTimeData(productItemData);
//                }
//
//            } catch (Exception e) {
//                e.printStackTrace();
//            }
//        });
    }

    //安科瑞统一回复指令
    public void acrelReturnInstructions(ChannelHandlerContext ctx) {
        ByteBuf byteBufs = Unpooled.buffer();
        byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("55")));
        byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("bb")));
        byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("1")));
        byteBufs.writeShort(Integer.valueOf(StringUtil.hexToDecimal("0")));
        byteBufs.writeByte(Integer.valueOf(StringUtil.hexToDecimal("20")));
        ctx.channel().writeAndFlush(byteBufs);
    }
}
