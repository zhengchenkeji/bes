package com.zc.connect.nettyServer.ChildChannelHandler.ModbusHandler;

import com.ruoyi.common.constant.ModbusFunctions;
import com.ruoyi.common.core.redis.RedisCache;
import com.ruoyi.common.utils.DateUtils;
import com.zc.ApplicationContextProvider;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.common.constant.WebSocketEvent;
import com.zc.connect.business.dto.JsonMsg;
import com.zc.connect.business.dto.ReceiveMsg;
import com.zc.connect.business.handler.ModbusMsgReceive;
import com.zc.connect.config.CodeConfig;
import com.zc.connect.nettyClient.ClientHandler;
import com.zc.connect.util.MsgUtil;
import com.zc.connect.util.StringUtil;
import com.zc.efounder.JEnterprise.commhandler.PointDataResponse;
import com.zc.efounder.JEnterprise.domain.baseData.*;
import com.zc.efounder.JEnterprise.mapper.baseData.ProductMapper;
import com.zc.efounder.JEnterprise.mapper.commhandler.JobManagerMapper;
import com.zc.efounder.JEnterprise.service.baseData.impl.EquipmentServiceImpl;
import io.netty.buffer.ByteBuf;
import io.netty.buffer.Unpooled;
import io.netty.channel.ChannelHandlerContext;
import io.netty.util.CharsetUtil;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.net.InetSocketAddress;
import java.text.DecimalFormat;
import java.util.*;
import java.util.stream.Collectors;

/**
 * @Author: wanghongjie
 * @Description:
 * @Date: Created in 9:16 2023/3/9
 * @Modified By:
 */
@Component
public class ModbusServerHandlers {
    private static final Logger log = LoggerFactory.getLogger(ModbusServerHandlers.class);

    private static List<Product> productLists = new ArrayList<>();

    private static List<Equipment> equipmentTCPList = new ArrayList<>();

    //redis
    private RedisCache redisCache = ApplicationContextProvider.getBean(RedisCache.class);
    //产品
    private ProductMapper productMapper = ApplicationContextProvider.getBean(ProductMapper.class);
    //设备
    private static EquipmentServiceImpl equipmentService = ApplicationContextProvider.getBean(EquipmentServiceImpl.class);

    private static JobManagerMapper jobManagerMapper = ApplicationContextProvider.getBean(JobManagerMapper.class);

    /**
     * 回令业务处理
     * 解析
     */
    public void response_analysis(ChannelHandlerContext ctx, Object msg) throws Exception {

        JsonMsg jsonMsg = new JsonMsg();

        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;

        refreshDevice();

        String host = ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress();
        int post = ((InetSocketAddress) ctx.channel().remoteAddress()).getPort();


        ByteBuf byteBuf = (ByteBuf) msg;

        String msgs = MsgUtil.convertByteBufToString(byteBuf);

        if (msgs.equals(CodeConfig.UsrHeartbeat)) {//有人模块的心跳
            //返回响应消息报文
            byte[] bytes = msgs.getBytes(CharsetUtil.UTF_8);
            ByteBuf buf = Unpooled.wrappedBuffer(bytes);
            ctx.channel().writeAndFlush(buf);

            return;
        }

//        System.out.println(msgs);


        int TransActionId = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(0, 4)));//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。
        int protocal = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(4, 8)));//协议标识：2个字节 表示该条指令遵循ModbusTCP协议，一般都为00 00
        int msg_len = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(8, 12)));//报文长度：2个字节 表示后面数据的长度，有几个字节，高字节在前
        int slave_id = Integer.valueOf(msgs.substring(12, 14));//设备标识 1个字节
        int funcotion_code = Integer.valueOf(msgs.substring(14, 16));//功能码 1个字节

        Integer registerBeginAddress = null;////寄存器起始地址

        Integer registerLength = null;//寄存器数量

        Queue<JsonMsg> queue = ModbusSendSyncMsgHandler.msgQueue.get(host + ":" + post);

        if (queue != null && queue.size() > 0) {

            JsonMsg queueMsg = queue.peek(); // 返回队首元素，但是不删除。

            if ((String.valueOf(TransActionId) + protocal).equals(queueMsg.getUuid())) {
                registerBeginAddress = queueMsg.getRegisterBeginAddress();
                registerLength = queueMsg.getRegisterLength();
            }

        }

        System.out.println(registerLength);

        jsonMsg.setUuid(String.valueOf(TransActionId) + protocal);
        jsonMsg.setIp(host);
        jsonMsg.setPost(post);
        msgReceiptHandler(jsonMsg);

//        if (1 == 1) {
//            return;
//        }


        //判断功能码是否正确
        //可参考网址:https://blog.csdn.net/weixin_46304253/article/details/107960184?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&utm_relevant_index=17
        if (funcotion_code != ModbusFunctions.COIL_STATUS &&
                funcotion_code != ModbusFunctions.INPUT_STATUS &&
                funcotion_code != ModbusFunctions.HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.INPUT_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_ONE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_ONE_HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {

            return;
        }

        if (funcotion_code == ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {
            //控制指令下发成功
            clientMsgReceive.sendMessageBoolen(true);
            return;
        }

        //遍历配置产品,取出所有的网关设备(tcp)
        List<Equipment> equipmentList = getEquipmentTCPList();
        if (equipmentList.size() == 0) {
            return;
        }

        try {
            Long equipmentId = null;
            Long sonEquipmentId = null;

            for (Equipment equipment : equipmentList) {
                String HOST = equipment.getIpAddress();
                Integer PORT = Integer.parseInt(equipment.getPortNum());
                if (!host.equals(HOST) || post != PORT) {
                    continue;
                }
                equipmentId = equipment.getId();
            }

            if (equipmentId == null) {
                return;
            }

            //获取当前产品下所有的设备
            Long productId = null;
            Map<String, Equipment> equipmentLists =
                    redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

            for (Equipment equipment : equipmentLists.values()) {
                if (equipment.getpId() == null) {//网关设备或者直连设备
                    continue;
                }
                if (!equipment.getpId().equals(equipmentId)) {//判断设备的父节点是否等于网关设备或者直连设备
                    continue;
                }
                if (equipment.getSonAddress().intValue() != slave_id) {//子设备地址是否为推送的地址
                    continue;
                }

                //websocket推送设备在线离线状态

                clientMsgReceive.deviceState(host, post, equipment.getId(), true);
                sonEquipmentId = equipment.getId();
                productId = equipment.getProductId();

            }

            //获取设备所有的数据项
            Map<String, ProductItemData> productItemDataList =
                    redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

            List<ProductItemData> productItemDataLists = new ArrayList<>();
//            for (ProductItemData productItemData : productItemDataList.values()) {
//                if (productItemData.getProductId() != productId) {//判断数据项的产品id是否等于设备的产品id
//                    continue;
//                }
//                productItemDataLists.add(productItemData);
//                System.out.println(productItemData.getName()+":"+productItemData.getId()+":"+productItemData.getSortNum());
//            }

            /**使用stream流进行过滤排序*/
            Long finalProductId = productId;
            productItemDataLists = productItemDataList.values().stream()
                    .filter(itemData -> itemData.getProductId() == finalProductId)
                    .filter(itemData -> itemData.getItemDataId() == null)
                    .sorted(Comparator.comparing(ProductItemData::getSortNum))
                    .collect(Collectors.toList());

//            Collections.sort(productItemDataLists, new Comparator<ProductItemData>() {
//                @Override
//                public int compare(ProductItemData o1, ProductItemData o2) {
//                    return o1.getSortNum().intValue() - o2.getSortNum().intValue();
//                }
//            });
            Integer byteLength = Integer.valueOf(msgs.substring(16, 17));//字节数

            Integer lestLength = msgs.substring(17, msgs.length() - 1).length();


            if (lestLength % 4 != 0) {//不能被4整除,说明回复的消息有误,数据不完整

                ReceiveMsg<List<PointDataResponse>> msg1 = new ReceiveMsg<>();
                msg1.setCode(0);
                msg1.setIndex(4);

                clientMsgReceive.getMassgaeState(WebSocketEvent.MODBUS_DEVICE, msg1);
                return;
            } else {
                if (registerLength != (lestLength / 4)) {//发送的寄存器数量和回复的寄存器数量不相等,说明数据不完整

                    ReceiveMsg<List<PointDataResponse>> msg1 = new ReceiveMsg<>();
                    msg1.setCode(0);
                    msg1.setIndex(4);

                    clientMsgReceive.getMassgaeState(WebSocketEvent.MODBUS_DEVICE, msg1);
                    return;
                }
            }

            int size = 0;
            System.out.println("接收传入的数据值：" + msgs);

            for (ProductItemData productItemData : productItemDataLists) {
//                System.out.println(productItemData.getName()+":"+productItemData.getId()+":"+productItemData.getSortNum());
                if (size > registerLength) {
                    continue;
                }


                Long sortNum = productItemData.getSortNum();
                if (sortNum.intValue() < registerBeginAddress) {
                   continue;
                }

                if (sortNum.intValue() > registerLength) {
                    continue;
                }

                double x = 10;

                double y = size;

                Integer numByten = 4 * size;

                size = size + 1;

                String highLow = productItemData.getHighLow();//高低位 0-否;1-是;

                String binarySystem = productItemData.getBinarySystem();//二进制 0-否;1-是;

//                int readByteLength = productItemData.getByteLength().intValue();//获取读取的字节长度

                int dataType = Integer.valueOf(productItemData.getDataType());//数据类型

//                int ratioSize = Integer.valueOf(productItemData.getRatioSize());//比率
//
//                int radixPoint = Integer.valueOf(productItemData.getRadixPoint());//小数点位置

                ;

                //todo 目前先不判断高低位中有2进制数据
                //判断是否高低位
                if (highLow.equals("1")){//是

                    /**根据寄存器地址截取数据*/
                    Long beginNum=18+(sortNum*4);
                    Long endNum=18+(sortNum*4)+2;
                    /**减去起始数量*/

                    beginNum=beginNum-(registerBeginAddress*4);
                    endNum=endNum-(registerBeginAddress*4);
                   /**获取高位数据项*/
                    Integer highData = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(beginNum.intValue(),endNum.intValue())));//高位数据
                    /**获取到高位数据项配置处理数据项*/
                    if(productItemData.getHighDetail()==null
                            ||productItemData.getHighDetail().size()==0
                            ||productItemData.getLowDetail()==null
                            ||productItemData.getLowDetail().size()==0){
                        log.error(productItemData.getName()+":该数据项高低位配置不完整");
                        continue;
                    }
                    /**暂不考虑二进制数据，默认获取非二进制唯一的高低位参数配置*/
                    ProductItemData highitem = productItemData.getHighDetail().get(0);
                    /**处理数据*/
                    executeSaveItemDate(highData, highitem, sonEquipmentId);

                    /**处理底位数据*/
                    /**根据寄存器地址截取数据*/

                    beginNum=beginNum+2;
                    endNum=endNum+2;
                    ProductItemData lowitem = productItemData.getLowDetail().get(0);

                    Integer lowData = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(beginNum.intValue(),endNum.intValue())));//低位
                    executeSaveItemDate(lowData,lowitem,sonEquipmentId);
                    continue;
                }

                //判断数据类型
                 if (dataType == 7) {//结构体
                     /**根据寄存器地址截取数据*/
                     Long beginNum=18+(sortNum*4);
                     Long endNum=18+(sortNum*4)+4;
                     /**减去起始数量*/
                     beginNum=beginNum-(registerBeginAddress*4);
                     endNum=endNum-(registerBeginAddress*4);
                     String dataValue="";
                     /**判断是否需要转为二进制*/
                     String hex = msgs.substring(beginNum.intValue(), endNum.intValue());

                     if(binarySystem.equals("0")){
                         //否 转为10进制
                         dataValue = StringUtil.hexToDecimal(hex);
                         // TODO: 2023/3/30 暂时不做十进制处理
                     }else{//是
                          dataValue = StringUtil.hex2Binary(hex);
                     }
                     /**根据配置的通道数量处理*/
                     List<ProductItemData> structDetailList = productItemData.getStructDetail();
//                     System.out.println("排序前");
//                     structDetailList.forEach(itemData -> System.out.println(JSONObject.toJSONString(itemData)));
//                     structDetailList=structDetailList.stream().sorted(Comparator.comparing(ProductItemData::getDataItemNum).reversed()).collect(Collectors.toList());
//                     System.out.println("排序后");
//                     structDetailList.forEach(itemData -> System.out.println(JSONObject.toJSONString(itemData)));

                     List<Integer> hex2List=new ArrayList<>();
                     /**切割为char数组*/
                     char[] chars =dataValue.toCharArray();
                     for (char value : chars) {
                         hex2List.add(Integer.parseInt(value+""));
                     }

                     if(hex2List.size()!=structDetailList.size()){
                         /**数据不对应代表前面的二进制数字为0*/
                         int diff= structDetailList.size()-hex2List.size();
                         for (int i = 0; i < diff; i++) {
                             /**插入头部*/
                             hex2List.add(0,0);
                         }
                     }
                     /**倒置数据*/
                     Collections.reverse(hex2List);
                     for (int index = 0; index < structDetailList.size(); index++) {
                         executeSaveItemDate(hex2List.get(index),structDetailList.get(index),sonEquipmentId);
                     }



                 } else {
                     Long beginNum=18+(sortNum*4);
                     Long endNum=18+(sortNum*4)+4;
                     /**减去起始数量*/

                     beginNum=beginNum-(registerBeginAddress*4);
                     endNum=endNum-(registerBeginAddress*4);
                     Integer dataValue = Integer.valueOf(StringUtil.hexToDecimal(msgs.substring(beginNum.intValue(), endNum.intValue())));
                     executeSaveItemDate(dataValue,productItemData,sonEquipmentId);
//                     System.out.println("3:"+dataValue+"::::"+msgs.substring(18 + numByten, 20 + numByten));
                }


            }


//            Set<Integer> keys = productItemDataMap.keySet();
//            for (Integer key : keys) {
//                if (key != funcotion_code) {
//                    continue;
//                }
//                List<ProductItemData> productItemData = productItemDataMap.get(key);
//                if (productItemData.size() == 0) {
//                    continue;
//                }
//
//                Collections.sort(productItemData, new Comparator<ProductItemData>() {
//                    @Override
//                    public int compare(ProductItemData o1, ProductItemData o2) {
//                        return o1.getSortNum().intValue() - o2.getSortNum().intValue();
//                    }
//                });
//
//                //获取当前功能码第一个寄存器地址
//                Integer firstByteNum = productItemData.get(0).getSortNum().intValue();
//                productItemData.forEach(val -> {
//                    Integer byteNum = val.getSortNum().intValue();//寄存器地址
//
////                        Short s = shortList.get(byteNum - firstByteNum);
////                        val.setDataValue(BigDecimal.valueOf(s));
////                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
////                        System.out.println(s);
//                });
//            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        //判断当前协议类型,是tcp或者udp

//        ModbusMsgReceive modbusMsgReceive = ClientHandler.modbusMsgReceive;
//        modbusMsgReceive.sendRegistrationMessage("1");


      /*  ThreadPool.executor.execute(() -> {
            //遍历配置产品,取出所有的网关设备(tcp)
            List<Equipment> equipmentList = getEquipmentTCPList();
            if (equipmentList.size() == 0) {
                return;
            }
            try {

                equipmentList.forEach(val -> {

                    String HOST = val.getIpAddress();
                    Integer PORT = Integer.parseInt(val.getPortNum());
                    if (!host.equals(HOST) || 9001 != PORT) {
                        return;
                    }

                    //获取当前产品下所有的设备
                    Map<String, Equipment> equipmentLists = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);
                    equipmentLists.values().forEach(val1 -> {
                        if (val1.getpId() == null) {//网关设备或者直连设备
                            return;
                        }
                        if (!val1.getpId().equals(val.getId())) {
                            return;
                        }
                        if (val1.getSonAddress().intValue() != slave_id) {
                            return;
                        }

                        //websocket推送设备在线离线状态
                        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;
                        clientMsgReceive.deviceState(host, 9001, val1.getId(), true);

                        //获取设备所有的数据项
                        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

                        productItemDataList.values().forEach(val2 -> {
                            if (val2.getProductId() != val1.getProductId()) {
                                return;
                            }
                            if (!productItemDataMap.containsKey(Integer.valueOf(val2.getFunctionCode()))) {//当前key不存在
                                List<ProductItemData> productItemData = new ArrayList<>();
                                productItemData.add(val2);
                                productItemDataMap.put(Integer.valueOf(val2.getFunctionCode()), productItemData);
                            } else {
                                List<ProductItemData> productItemData = productItemDataMap.get(Integer.valueOf(val2.getFunctionCode()));
                                productItemData.add(val2);
                            }
                        });
                    });
                });

                Set<Integer> keys = productItemDataMap.keySet();
                for (Integer key : keys) {
                    if (key != funcotion_code) {
                        continue;
                    }
                    List<ProductItemData> productItemData = productItemDataMap.get(key);
                    if (productItemData.size() == 0) {
                        continue;
                    }

                    Collections.sort(productItemData, new Comparator<ProductItemData>() {
                        @Override
                        public int compare(ProductItemData o1, ProductItemData o2) {
                            return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                        }
                    });

                    //获取当前功能码第一个寄存器地址
                    Integer firstByteNum = productItemData.get(0).getSortNum().intValue();
                    productItemData.forEach(val -> {
                        Integer byteNum = val.getSortNum().intValue();//寄存器地址

//                        Short s = shortList.get(byteNum - firstByteNum);
//                        val.setDataValue(BigDecimal.valueOf(s));
//                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
//                        System.out.println(s);
                    });
                }
            } catch (Exception e) {
                e.printStackTrace();
            }


        });*/
    }

    /**
     * @param data     数据值
     * @param itemData 数据项配置
     * @description:处理数据项数据
     * @author: sunshangeng
     * @date: 2023/3/30 14:40
     * @return: void
     **/
    public void executeSaveItemDate(Integer data, ProductItemData itemData, Long equipmentId) {

        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;

        PointDataResponse pointDataResponse = new PointDataResponse();


        List<PointDataResponse> pointDataResponseList = new ArrayList<>();

        pointDataResponseList.add(pointDataResponse);


        System.out.println("处理数据数据项：" + itemData.getName() + ",数据值：" + data);
        data = data * Integer.parseInt(itemData.getRatioSize());
        float floatData = (float) data / ((int) Math.pow(10, (double) Integer.valueOf(itemData.getRadixPoint())));

        DecimalFormat df1 = new DecimalFormat("0.00");//保留两位小数，如果是零点几，小数点后几个零就保留几位

        String stringData  = rvZeroAndDot(Float.toString(Float.parseFloat(df1.format(floatData))));

        pointDataResponse.setModbusId(itemData.getId() + "+" + equipmentId);
        pointDataResponse.setValue(stringData);

        ReceiveMsg<List<PointDataResponse>> msg1 = new ReceiveMsg<>();
        msg1.setData(pointDataResponseList);
        msg1.setCode(1);
        msg1.setIndex(4);

        clientMsgReceive.getMassgaeState(WebSocketEvent.MODBUS_DEVICE, msg1);


        itemData.setDataValue(BigDecimal.valueOf(data));
        /**判断是否存储数据*/
        if (itemData.getPreserveType().equals("1")) {
            Equipment equipment = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment, equipmentId);
            /**判断是否是电表*/
            if (equipment.getMeterState().equals("1")) {
                Map<String, Object> dataMap = new HashMap<>();
                dataMap.put("id", DateUtils.dateTimeNow() + "_" + itemData.getId());
                dataMap.put("meteruuid", equipment.getName());
                dataMap.put("data", stringData);
                dataMap.put("l_time", DateUtils.getTime());
                dataMap.put("parkid", equipment.getParkCode());
                dataMap.put("electricId", itemData.getId());
                List<Map<String, Object>> mapList = new ArrayList<>();
                mapList.add(dataMap);
                /**插入电表数据表*/
                jobManagerMapper.insertCalculateData(mapList);
                /**插入电表原始数据表*/
                jobManagerMapper.insertEnectricData(mapList);
            } else {
                /**非电表*/
                equipmentService.insertHistoryData(new HistoryItemData(itemData.getId(), itemData.getDataValue(), equipmentId));
            }
            /**存储*/
        }
        /**处理缓存item*/
        ProductItemRealTimeData productItemRealTimeData = ProductItemRealTimeData.CreateRealTimeData(itemData.getId(), equipmentId, stringData);
        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData_RealTime, productItemRealTimeData.getId(), productItemRealTimeData);

    }

    public static String rvZeroAndDot(String val) {

        if (val.indexOf(".") > 0) {

            // 去掉多余的0

            val = val.replaceAll("0+?$", "");

            // 如最后一位是.则去掉

            val = val.replaceAll("[.]$", "");
        }
        return val;

    }

    //刷新设备
    public void refreshDevice() {

        getProductLists().clear();
        equipmentTCPList.clear();

        //遍历配置产品,取出所有的网关设备(tcp)
        Map<String, Product> productList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product);
        if (productList == null || productList.size() == 0) {
            return;
        }

        productList.values().forEach(val -> {
            if (val.getIotType().equals("0") || val.getIotType().equals("1")) {//直连设备或者网关设备
                getProductLists().add(val);
            }
        });

        if (getProductLists().size() == 0) {
            return;
        }

        Map<String, Equipment> controllerList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

        if (controllerList == null || controllerList.size() == 0) {
            return;
        }

        controllerList.values().forEach(val -> {
            if (val.getNetworkType() == null) {
                return;
            }
            if (!val.getNetworkType().equals("0")) {//0-下位机客户端;1-下位机服务端
                return;
            }
            getProductLists().forEach(val1 -> {
                if (val1.getId() == val.getProductId()) {
                    equipmentTCPList.add(val);
                }
            });

        });
    }


    /**
     * 消息回执处理
     * 1.根据通道id获取消息队列
     * 2.获取队列中的消息
     * 3.如果消息是队列中的回复消息，则弹出该消息队列
     * 4.如果队列中有下一个消息则直接发送
     *
     * @param msg
     */
    public static void msgReceiptHandler(JsonMsg msg) {
        if (msg == null) {
            return;
        }

        String uuid = msg.getUuid();
        String ip = msg.getIp();
        Integer port = msg.getPost();

        if (uuid == null || uuid.isEmpty() || ip == null || ip.isEmpty()) {
            return;
        }

        Queue<JsonMsg> queue = ModbusSendSyncMsgHandler.msgQueue.get(ip + ":" + port);

        if (queue == null || queue.isEmpty()) {
            return;
        }

        JsonMsg queueMsg = queue.peek(); // 返回队首元素，但是不删除。

        if (uuid.equals(queueMsg.getUuid())) {
            queue.poll(); // 从队首删除并返回该元素

            JsonMsg nextMsg = queue.peek();

            if (nextMsg == null) {
                return;
            }

            ModbusSendSyncMsgHandler.postEvent(ip, port, nextMsg);
        } else {
            ModbusSendSyncMsgHandler.postEvent(ip, port, queueMsg);
        }

    }

    public static List<Product> getProductLists() {
        return productLists;
    }

    public static void setProductLists(List<Product> productLists) {
        ModbusServerHandlers.productLists = productLists;
    }

    public static List<Equipment> getEquipmentTCPList() {
        return equipmentTCPList;
    }

    public static void setEquipmentTCPList(List<Equipment> equipmentTCPList) {
        ModbusServerHandlers.equipmentTCPList = equipmentTCPList;
    }


    /**
     * 每分钟触发
     */
    @Scheduled(cron = "0 */1 * * * ?")
    public void sendmsg() {

    }


}
