package com.zc.connect.nettyServer.ChildChannelHandler.ModbusHandler;

import com.ruoyi.common.constant.ModbusFunctions;
import com.ruoyi.common.core.redis.RedisCache;
import com.zc.ApplicationContextProvider;
import com.zc.common.constant.RedisKeyConstants;
import com.zc.common.core.ThreadPool.ThreadPool;
import com.zc.connect.business.handler.ModbusMsgReceive;
import com.zc.connect.nettyClient.ClientHandler;
import com.zc.efounder.JEnterprise.domain.baseData.Equipment;
import com.zc.efounder.JEnterprise.domain.baseData.Product;
import com.zc.efounder.JEnterprise.domain.baseData.ProductItemData;
import io.netty.buffer.ByteBuf;
import io.netty.channel.*;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.math.BigDecimal;
import java.net.InetSocketAddress;
import java.util.*;

/**
 * @Author: wanghongjie
 * @Description:
 * @Date: Created in 9:16 2023/3/9
 * @Modified By:
 */
@Component
public class ModbusServerHandlers {
    private static final Logger log = LoggerFactory.getLogger(ModbusServerHandlers.class);

    private static List<Product> productLists = new ArrayList<>();

    private static List<Equipment> equipmentTCPList = new ArrayList<>();

    //redis
    private RedisCache redisCache = ApplicationContextProvider.getBean(RedisCache.class);

    /**
     * 回令业务处理
     * 解析
     */
    public void response_analysis(ChannelHandlerContext ctx, Object msg) throws Exception {

        refreshDevice();

        ByteBuf byteBuf = (ByteBuf) msg;


        short TransActionId = byteBuf.readShort();//交互（通信）标识：2个字节 为此次通信事务处理标识符，一般每次通信之后将被要求加1以区别不同的通信数据报文。
        short protocal = byteBuf.readShort();//协议标识：2个字节 表示该条指令遵循ModbusTCP协议，一般都为00 00
        short msg_len = byteBuf.readShort();//报文长度：2个字节 表示后面数据的长度，有几个字节，高字节在前
        byte slave_id = byteBuf.readByte();//设备标识 1个字节
        byte funcotion_code = byteBuf.readByte();//功能码 1个字节
//        byte byte_msg_hig = byteBuf.readByte();//高字节起始地址 1个字节
//        byte byte_msg_low = byteBuf.readByte();//高字节起始地址 1个字节

        //判断功能码是否正确
        //可参考网址:https://blog.csdn.net/weixin_46304253/article/details/107960184?spm=1001.2101.3001.6650.8&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-8-107960184-blog-78174071.pc_relevant_aa&utm_relevant_index=17
        if (funcotion_code != ModbusFunctions.COIL_STATUS &&
                funcotion_code != ModbusFunctions.INPUT_STATUS &&
                funcotion_code != ModbusFunctions.HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.INPUT_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_ONE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_ONE_HOLDING_REGISTER &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_COIL &&
                funcotion_code != ModbusFunctions.WRITE_MULTIPLE_HOLDING_REGISTER) {

            return;
        }

//        if (msg_len != byte_msg_hig + byte_msg_low + 2) {//功能码错误或者存在粘包问题
//            return;
//        }

        String host = ((InetSocketAddress) ctx.channel().remoteAddress()).getAddress().getHostAddress();
        int post = ((InetSocketAddress) ctx.channel().remoteAddress()).getPort();


                //判断当前协议类型,是tcp或者udp

        ModbusMsgReceive modbusMsgReceive = ClientHandler.modbusMsgReceive;
        modbusMsgReceive.sendRegistrationMessage("1");
        System.out.println("---------------start process msg--------------------");
        System.out.println("readable bytes is:"+byteBuf.readableBytes());

        int[] buffer = new int[20];
        if(funcotion_code ==4 || funcotion_code ==3 )//如果功能码是4，也就是读请求，我们要返回结果
        {   //输出
            short start_address = byteBuf.readShort();
            short ncount = byteBuf.readShort();
            System.out.println("TransactionID is:"+ TransActionId);
            System.out.println("protocal id is:"+protocal);
            System.out.println("msg len is:"+msg_len);
            System.out.println("slave id  is:"+slave_id);
            System.out.println("function code is:"+funcotion_code);
            System.out.println("start address is:"+start_address);
            System.out.println("count  is:"+ncount);
            //返回响应消息报文
            ByteBuf out = ctx.alloc().directBuffer(110);
            out.writeShort(TransActionId);//Transaction ID  2
            out.writeShort(protocal);//protocal id     2
            out.writeShort(23);//msg len        2
            out.writeByte(slave_id);//slave id         1
            out.writeByte(funcotion_code);//function code    1
            //out.writeShort(0);//start address 2
            out.writeByte(20);//46个寄存器      46*2

            buffer[1] = 1;

            buffer[3] = 15;
            for(int i=0;i<20;i++)
                out.writeByte(buffer[i]);

            ChannelId channelId = ServerHandler_modbus.channels.get(host);
            Channel channel = ServerHandler_modbus.clients.find(channelId);
            ChannelFuture future = channel.writeAndFlush(byteBuf);
            future.addListener(new ChannelFutureListener() {

                @Override
                public void operationComplete(ChannelFuture future) throws Exception {

                    if (future.isSuccess()) {
                        System.out.println("===========发送成功");
                    } else {
                        System.out.println("------------------发送失败");
                    }
                }
            });
            ctx.channel().writeAndFlush(out);
        }


        //功能码和数据项键值对
        Map<Integer, List<ProductItemData>> productItemDataMap = new HashMap<>();

        ThreadPool.executor.execute(() -> {
            //遍历配置产品,取出所有的网关设备(tcp)
            List<Equipment> equipmentList = getEquipmentTCPList();
            if (equipmentList.size() == 0) {
                return;
            }
            try {

                equipmentList.forEach(val -> {

                    String HOST = val.getIpAddress();
                    Integer PORT = Integer.parseInt(val.getPortNum());
                    if (!host.equals(HOST) || 9001 != PORT) {
                        return;
                    }

                    //获取当前产品下所有的设备
                    Map<String, Equipment> equipmentLists = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);
                    equipmentLists.values().forEach(val1 -> {
                        if (val1.getpId() == null) {//网关设备或者直连设备
                            return;
                        }
                        if (!val1.getpId().equals(val.getId())) {
                            return;
                        }
                        if (val1.getSonAddress().intValue() != slave_id) {
                            return;
                        }

                        //websocket推送设备在线离线状态
                        ModbusMsgReceive clientMsgReceive = ClientHandler.modbusMsgReceive;
                        clientMsgReceive.deviceState(host, 9001, val1.getId(), true);

                        //获取设备所有的数据项
                        Map<String, ProductItemData> productItemDataList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData);

                        productItemDataList.values().forEach(val2 -> {
                            if (val2.getProductId() != val1.getProductId()) {
                                return;
                            }
                            if (!productItemDataMap.containsKey(Integer.valueOf(val2.getFunctionCode()))) {//当前key不存在
                                List<ProductItemData> productItemData = new ArrayList<>();
                                productItemData.add(val2);
                                productItemDataMap.put(Integer.valueOf(val2.getFunctionCode()), productItemData);
                            } else {
                                List<ProductItemData> productItemData = productItemDataMap.get(Integer.valueOf(val2.getFunctionCode()));
                                productItemData.add(val2);
                            }
                        });
                    });
                });

                Set<Integer> keys = productItemDataMap.keySet();
                for (Integer key : keys) {
                    if (key != funcotion_code) {
                        continue;
                    }
                    List<ProductItemData> productItemData = productItemDataMap.get(key);
                    if (productItemData.size() == 0) {
                        continue;
                    }

                    Collections.sort(productItemData, new Comparator<ProductItemData>() {
                        @Override
                        public int compare(ProductItemData o1, ProductItemData o2) {
                            return o1.getSortNum().intValue() - o2.getSortNum().intValue();
                        }
                    });

                    //获取当前功能码第一个寄存器地址
                    Integer firstByteNum = productItemData.get(0).getSortNum().intValue();
                    productItemData.forEach(val -> {
                        Integer byteNum = val.getSortNum().intValue();//寄存器地址

//                        Short s = shortList.get(byteNum - firstByteNum);
//                        val.setDataValue(BigDecimal.valueOf(s));
//                        redisCache.setCacheMapValue(RedisKeyConstants.BES_BasicData_Product_ItemData,val.getId(),val);
//                        System.out.println(s);
                    });
                }
            } catch (Exception e) {
                e.printStackTrace();
            }


        });
        //回复心跳


//        InetSocketAddress ipSocket = (InetSocketAddress)ctx.channel().remoteAddress();
//
//        //客户端IP地址
//        String ip = ipSocket.getAddress().getHostAddress();
//
//        //判断当前协议类型,是tcp或者udp
//
//        System.out.println(ip);
//        ModbusMsgReceive modbusMsgReceive = ClientHandler.modbusMsgReceive;
//        modbusMsgReceive.sendRegistrationMessage("1");
//        ByteBuf byteBuf = (ByteBuf) msg;
//        System.out.println("---------------start process msg--------------------");
//        System.out.println("readable bytes is:"+byteBuf.readableBytes());
//        short TransActionId = byteBuf.readShort();
//        short protocal = byteBuf.readShort();
//        short msg_len = byteBuf.readShort();
//        byte slave_id = byteBuf.readByte();
//        byte funcotion_code = byteBuf.readByte();
//
//        int[] buffer = new int[20];
//        if(funcotion_code ==4 || funcotion_code ==3 )//如果功能码是4，也就是读请求，我们要返回结果
//        {   //输出
//            short start_address = byteBuf.readShort();
//            short ncount = byteBuf.readShort();
//            System.out.println("TransactionID is:"+ TransActionId);
//            System.out.println("protocal id is:"+protocal);
//            System.out.println("msg len is:"+msg_len);
//            System.out.println("slave id  is:"+slave_id);
//            System.out.println("function code is:"+funcotion_code);
//            System.out.println("start address is:"+start_address);
//            System.out.println("count  is:"+ncount);
//            //返回响应消息报文
//            ByteBuf out = ctx.alloc().directBuffer(110);
//            out.writeShort(TransActionId);//Transaction ID  2
//            out.writeShort(protocal);//protocal id     2
//            out.writeShort(23);//msg len        2
//            out.writeByte(slave_id);//slave id         1
//            out.writeByte(funcotion_code);//function code    1
//            //out.writeShort(0);//start address 2
//            out.writeByte(20);//46个寄存器      46*2
//
//            buffer[1] = 1;
//
//            buffer[3] = 15;
//            for(int i=0;i<20;i++)
//                out.writeByte(buffer[i]);
//            ctx.channel().writeAndFlush(out);
//
//        }
//        else if(funcotion_code == 0x10)
//        {
//            short start_address = byteBuf.readShort();
//
//            short nWords = byteBuf.readShort();
//            byte  ncount = byteBuf.readByte();
//
//            //更新本地buffer
//            for(int i=0;i<ncount;i++)
//                buffer[start_address*2+i] = byteBuf.readByte();
//            //printMsg();
//            //返回响应消息
//            ByteBuf out = ctx.alloc().directBuffer(93);
//            out.writeShort(0);//Transaction ID  2
//            out.writeShort(0);//protocal id     2
//            out.writeShort(0);//msg len         2
//            out.writeByte(1);//slave id         1
//            out.writeByte(0x10);//function code    1
//            out.writeShort(start_address);//46个寄存器      46*2
//            out.writeShort(ncount);//ncuont  2
//            ctx.channel().writeAndFlush(out);
//            //System.out.println("response write success,write words is:"+out.readableBytes());
//            //out.release();
//        }
//        else{
//            System.out.println("error function");
//        }
//
//        //读取客户端指令
//
//        Channel channel = MsgUtil.getChannelByTokenSN(ip);
//
//        if (channel == null)
//        {
//        } else {
//            ByteBuf out = ctx.alloc().directBuffer(93);
//            out.writeShort(TransActionId);//Transaction ID  2
//            out.writeShort(protocal);//protocal id     2
//            out.writeShort(23);//msg len        2
//            out.writeByte(slave_id);//slave id         1
//            out.writeByte(funcotion_code);//function code    1
//            //out.writeShort(0);//start address 2
//            out.writeByte(20);//46个寄存器      46*2
//
//            buffer[1] = 1;
//
//            buffer[3] = 20;
//            for(int i=0;i<20;i++)
//                out.writeByte(buffer[i]);
//            channel.writeAndFlush(out);
//        }
//
//        byteBuf.release();

    }


    //刷新设备
    public void refreshDevice() {

        getProductLists().clear();
        equipmentTCPList.clear();

        //遍历配置产品,取出所有的网关设备(tcp),进行连接
        Map<String, Product> productList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Product);
        if (productList == null || productList.size() == 0) {
            return;
        }

        productList.values().forEach(val -> {
            if (val.getIotType().equals("0") || val.getIotType().equals("1")) {//直连设备或者网关设备
                getProductLists().add(val);
            }
        });

        if (getProductLists().size() == 0) {
            return;
        }

        Map<String, Equipment> controllerList = redisCache.getCacheMapValue(RedisKeyConstants.BES_BasicData_Equipment);

        if (controllerList == null || controllerList.size() == 0) {
            return;
        }

        controllerList.values().forEach(val -> {
            if (val.getNetworkType() == null) {
                return;
            }
            if (!val.getNetworkType().equals("0")) {//0-客户端;1-服务端
                return;
            }
            getProductLists().forEach(val1 -> {
                if (val1.getId() == val.getProductId()) {
                    equipmentTCPList.add(val);
                }
            });

        });
    }


    public static List<Product> getProductLists() {
        return productLists;
    }

    public static void setProductLists(List<Product> productLists) {
        ModbusServerHandlers.productLists = productLists;
    }

    public static List<Equipment> getEquipmentTCPList() {
        return equipmentTCPList;
    }

    public static void setEquipmentTCPList(List<Equipment> equipmentTCPList) {
        ModbusServerHandlers.equipmentTCPList = equipmentTCPList;
    }
}
